---
title: "Introduction to EDA"
author: "Pramod Duvvuri"
date: "3/11/2019"
output:
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=9, fig.height=5) 
```

# Univariate Data

## Learning Grammar of Graphics (ggplot2)

```{r}
# Load installed packages
library('lattice')
library('ggplot2')
```

```{r}
ggplot(singer, aes(x = height))
```

```{r}
# ECDF in ggplot2
ggplot(singer, aes(x = height)) + stat_ecdf()
```

### Basic Plots

```{r}
# Alternate way to get ECDF
singer_gg <- ggplot(singer, aes(x = height))
singer_gg + stat_ecdf()
```

```{r}
# Add Labels
singer_gg + stat_ecdf() + ggtitle('ECDF')
```

```{r}
# Histogram
#ggplot(singer, aes(x= height)) + geom_histogram()
ggplot(singer, aes(x= height)) + geom_histogram(binwidth = 1)
```

```{r}
# Density Plot
ggplot(singer, aes(x= height)) + 
  geom_density()

ggplot(singer, aes(x= height)) + 
  geom_density(adjust = 0.5)
```

```{r}
# Boxplot 
ggplot(singer, aes(x= "Height", y = height)) + geom_boxplot()
```

```{r}
# Multiple Boxplots
ggplot(singer, aes(x = voice.part, y = height)) + geom_boxplot()
```

```{r}
# QQ-Plot using a Normal Distribution
ggplot(singer, aes(sample = height)) + stat_qq()
```

```{r}
# QQ-Plot using a Uniform Distribution
ggplot(singer, aes(sample = height)) + 
  stat_qq(distribution = qunif)
```

```{r}
# Facet
ggplot(singer,aes(sample = height)) + 
  stat_qq(distribution = qunif) +
  facet_grid(~voice.part)
```

```{r}
# The plot above looks cramped, so let us try a grid with columns
ggplot(singer, aes(sample = height)) + 
  stat_qq(distribution = qunif) +
  facet_wrap(~voice.part, ncol = 2)
```

```{r}
# QQ-Plot using Base R function qqplot()
Tenor1 = singer$height[singer$voice.part == "Tenor 1"]
Bass2 = singer$height[singer$voice.part == "Bass 2"]
qqplot(Tenor1, Bass2)
abline(0, 1)
```

```{r}
# Using ggplot
#library(tibble)
#qq_df <- as.tibble(qqplot(Tenor1, Bass2, plot.it = FALSE))
qq_df <- as.data.frame(qqplot(Tenor1, Bass2, plot.it = FALSE))
ggplot(data = qq_df, mapping = 
         aes(x = x, y = y)) + 
  geom_point() + 
  geom_abline()
```

```{r}
## Tukey-Mean difference Plot
ggplot(data = qq_df, mapping = aes(x = (x + y)/2, y = y - x)) + 
  geom_point() + 
  geom_abline(slope = 0) + ggtitle("Tukey Mean-Difference Plot")
```

```{r}
singer_means <- aggregate(height ~ voice.part, FUN = mean, data = singer)
```

```{r}
ggplot(singer_means, aes(x = voice.part, y = height)) + geom_point() + coord_flip()
```

```{r}
# Fitting a linear model
singer.lm <- lm(height ~ voice.part, data = singer)
```

```{r}
# Extracting residual values
singer.res <- data.frame(voice.part = singer$voice.part, residual = residuals(singer.lm))
```

```{r}
# Observing Residuals using boxplots
ggplot(singer.res, aes(x = voice.part, y = residual)) + geom_boxplot() + coord_flip()
```

```{r}
# Checking normality of residuals
ggplot(singer.res, aes(sample = residual)) + 
  stat_qq() + 
  facet_wrap(~voice.part, ncol = 2)
```

```{r}
# QQ Plot for Normality
ggplot(singer.res, aes(sample = residual)) + 
  stat_qq()
```

```{r}
# QQ Plot for Normality and adding slope and intercept
ggplot(singer.res, aes(sample = residual)) + 
  stat_qq() + geom_abline(intercept = 0,
slope = summary(singer.lm)$sigma)
```

```{r}
# Prepare Data
singer.fitted <- sort(fitted.values(singer.lm)) - mean(fitted.values(singer.lm))
singer.residuals <- sort(residuals(singer.lm))
n = length(singer.residuals)
f.value = (0.5:(n - 0.5))/n
singer.fit = data.frame(f.value, Fitted = singer.fitted, Residuals = singer.residuals)
```

```{r}
library(tidyr)
singer.fit.long = singer.fit %>% gather(type, value, Fitted:Residuals)
```

```{r}
# Residual-Fit spread plot
ggplot(singer.fit.long, aes(x = f.value, y = value)) + 
  geom_point() + 
  facet_wrap(~type)
```

```{r}
# Using stat_qq() to calculate f-values
ggplot(singer.fit.long, aes(sample = value)) + 
  stat_qq(distribution = "qunif") + 
  facet_grid(~type)
```

```{r}
# Using R-Squared
round(var(singer.fitted)/var(singer$height),3)
```

```{r}
url <- "https://github.com/hadley/tidy-data/raw/master/data/billboard.csv"
billboard.raw <- read.csv(url, stringsAsFactors = FALSE)
```

```{r}
# Creating a Tibble
library(dplyr)
billboard <- tbl_df(billboard.raw)
billboard
```

```{r}
# Calculating time-length of each song
billboard.time <- strsplit(billboard$time, ":")
billboard.time <- matrix(unlist(billboard.time), byrow = T, ncol = 2)
billboard.mins <- as.numeric(billboard.time[, 1])
billboard.secs <- as.numeric(billboard.time[, 2])
billboard.time <- billboard.mins * 60 + billboard.secs
billboard$time <- billboard.time/60
```

```{r}
billboard.long <- billboard %>% 
  gather(week, rank, x1st.week:x76th.week, na.rm = TRUE)
billboard.long
```

```{r}
ggplot(billboard, aes(x = time)) + 
  geom_histogram(breaks = seq(2.5, 8, 0.25))
```

```{r}
# Finding mean song length
time.means = aggregate(time ~ rank, FUN = mean, data = billboard.long)
```

```{r}
# Plotting mean song lenghts
ggplot(time.means, aes(x = rank, y = time)) + geom_line()
```

### Transformations

```{r}
# Load data from workspace
load("./data/lattice.RData")
```

